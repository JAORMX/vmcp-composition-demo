# Virtual MCP Server Configuration - Composition Demo
# This configuration showcases composite tools that orchestrate
# multi-step workflows across multiple backend MCP servers.

name: "composition-demo"
group: "default"  # References ToolHive group with backend servers

# Server settings
port: 4483
log_level: "info"

# Authentication: Anonymous for demo purposes
incoming_auth:
  type: anonymous

# Outgoing authentication (Virtual MCP â†’ Backends)
outgoing_auth:
  source: inline
  default:
    type: unauthenticated

# Aggregation settings
aggregation:
  conflict_resolution: prefix
  conflict_resolution_config:
    prefix_format: "{workload}_"

# ============================================================================
# COMPOSITE TOOLS
# ============================================================================
# These multi-step workflows demonstrate Virtual MCP's orchestration
# capabilities, including parallel execution, output aggregation, and
# cross-backend coordination.

composite_tools:
  # ==========================================================================
  # Use Case 1: Multi-Source Documentation Aggregator
  # ==========================================================================
  # Demonstrates: Parallel execution, output_format aggregation, timing
  #
  # This tool fetches documentation from multiple sources simultaneously
  # and aggregates them into a structured report with metadata.
  - name: "aggregate_docs"
    description: "Fetch and aggregate documentation from multiple sources in parallel"

    parameters:
      type: object
      properties:
        sources:
          type: "array"
          description: "List of documentation URLs to fetch"
          default:
            - "https://raw.githubusercontent.com/modelcontextprotocol/specification/main/README.md"
            - "https://raw.githubusercontent.com/modelcontextprotocol/python-sdk/main/README.md"
            - "https://raw.githubusercontent.com/modelcontextprotocol/servers/main/README.md"

    timeout: "2m"

    steps:
      # These three steps run in PARALLEL (no dependencies)
      - id: "fetch_source_1"
        type: "tool"
        tool: "fetch_fetch"
        arguments:
          url: "{{index .params.sources 0}}"
          max_length: 5000

      - id: "fetch_source_2"
        type: "tool"
        tool: "fetch_fetch"
        arguments:
          url: "{{index .params.sources 1}}"
          max_length: 5000

      - id: "fetch_source_3"
        type: "tool"
        tool: "fetch_fetch"
        arguments:
          url: "{{index .params.sources 2}}"
          max_length: 5000

    # Structured output schema with type-safe properties
    output:
      properties:
        summary:
          type: object
          description: "Workflow execution summary"
          properties:
            total_sources:
              type: integer
              description: "Total number of sources fetched"
              value: "3"
        source1_status:
          type: string
          description: "Status of first source fetch"
          value: "{{.steps.fetch_source_1.status}}"
        source1_preview:
          type: string
          description: "Preview of first source content"
          value: "{{.steps.fetch_source_1.output.text}}"
        source2_status:
          type: string
          description: "Status of second source fetch"
          value: "{{.steps.fetch_source_2.status}}"
        source2_preview:
          type: string
          description: "Preview of second source content"
          value: "{{.steps.fetch_source_2.output.text}}"
        source3_status:
          type: string
          description: "Status of third source fetch"
          value: "{{.steps.fetch_source_3.status}}"
        source3_preview:
          type: string
          description: "Preview of third source content"
          value: "{{.steps.fetch_source_3.output.text}}"

  # ==========================================================================
  # Use Case 2: GitHub Repository Health Check
  # ==========================================================================
  # Demonstrates: Conditional elicitation, skippable steps, sequential dependencies
  #
  # This tool analyzes a GitHub repository by fetching issues and commits.
  # If more than 3 issues are found, it prompts the user for confirmation
  # before continuing with commit analysis (elicitation step).
  - name: "analyze_repository"
    description: "Analyze a GitHub repository's health and activity"

    parameters:
      type: object
      properties:
        owner:
          type: "string"
          description: "Repository owner"
          default: "modelcontextprotocol"
        repo:
          type: "string"
          description: "Repository name"
          default: "specification"

    timeout: "2m"

    steps:
      # Step 1: List issues
      - id: "list_issues"
        type: "tool"
        tool: "github_list_issues"
        arguments:
          owner: "{{.params.owner}}"
          repo: "{{.params.repo}}"
          perPage: 5

      # Step 2: Elicitation - ask for confirmation if more than 3 issues
      - id: "confirm_continue"
        type: "elicitation"
        depends_on: ["list_issues"]
        condition: "{{gt (len (fromJson .steps.list_issues.output.text).issues) 3}}"
        message: "Found more than 3 issues in this repository. Do you want to continue analyzing commits?"
        schema:
          type: object
          properties:
            continue:
              type: boolean
              description: "Continue with commit analysis?"
          required:
            - continue
        onDecline:
          action: skip_remaining
        onCancel:
          action: abort

      # Step 3: List commits (depends on elicitation)
      - id: "list_commits"
        type: "tool"
        tool: "github_list_commits"
        depends_on: ["confirm_continue"]
        arguments:
          owner: "{{.params.owner}}"
          repo: "{{.params.repo}}"
          perPage: 3

    # Structured output schema for repository analysis
    output:
      properties:
        repository:
          type: string
          description: "Repository identifier"
          value: "{{.params.owner}}/{{.params.repo}}"
        activity:
          type: object
          description: "Repository activity information"
          properties:
            issues_status:
              type: string
              description: "Status of issues fetch operation"
              value: "{{.steps.list_issues.status}}"
            issues_preview:
              type: string
              description: "Preview of recent issues"
              value: "{{slice .steps.list_issues.output.text 0 200}}"
            commits_status:
              type: string
              description: "Status of commits fetch operation"
              value: "{{.steps.list_commits.status}}"
            commits_preview:
              type: string
              description: "Preview of recent commits"
              value: "{{slice (index .steps.list_commits.output \"text\") 0 200}}"
        issues_count:
          type: integer
          description: "Number of issues fetched"
          value: "{{len (index (fromJson .steps.list_issues.output.text) \"issues\")}}"

  # ==========================================================================
  # Use Case 3: Container Image Investigation
  # ==========================================================================
  # Demonstrates: OCI registry integration, nested data, real-world debugging
  #
  # This tool provides comprehensive analysis of a container image by
  # querying the OCI registry for metadata, manifest, and configuration.
  - name: "investigate_image"
    description: "Investigate a container image from an OCI registry"

    parameters:
      type: object
      properties:
        image:
          type: "string"
          description: "Image reference (e.g., docker.io/library/alpine:latest)"
          default: "docker.io/library/alpine:latest"

    timeout: "2m"

    steps:
      # Step 1: Get image information
      - id: "get_image_info"
        type: "tool"
        tool: "oci-registry_get_image_info"
        arguments:
          image_ref: "{{.params.image}}"

      # Step 2: Get manifest (runs in parallel with config)
      - id: "get_manifest"
        type: "tool"
        tool: "oci-registry_get_image_manifest"
        arguments:
          image_ref: "{{.params.image}}"
        depends_on: ["get_image_info"]

      # Step 3: Get config (runs in parallel with manifest)
      - id: "get_config"
        type: "tool"
        tool: "oci-registry_get_image_config"
        arguments:
          image_ref: "{{.params.image}}"
        depends_on: ["get_image_info"]

    # Structured output schema for image investigation
    output:
      properties:
        image:
          type: string
          description: "Container image reference"
          value: "{{.params.image}}"
        analysis:
          type: object
          description: "Image analysis results"
          properties:
            image_info:
              type: string
              description: "Basic image information"
              value: "{{slice .steps.get_image_info.output.text 0 150}}"
            manifest_preview:
              type: string
              description: "Preview of image manifest"
              value: "{{slice .steps.get_manifest.output.text 0 150}}"
            config_preview:
              type: string
              description: "Preview of image configuration"
              value: "{{slice .steps.get_config.output.text 0 150}}"
        all_steps_completed:
          type: boolean
          description: "Whether all steps completed successfully"
          value: "true"
          default: true
